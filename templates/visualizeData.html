{% from '_header.html' import header %}
{% from '_footer.html' import footer %}
{{ header(current_user=current_user, is_admin=is_admin, page_title="Visualize Device Data", scripts=[
    "https://cdn.jsdelivr.net/npm/chart.js",
    "https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns",
    "https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@^2.0.0"
]) }}
<div class="container mt-4">
    <h1 class="mb-4">Visualize Device Data</h1>
    <div class="row mb-3">
        <div class="col-12 col-md-6 mb-3 mb-md-0">
            <h5>1. Select Device(s)</h5>
            <select id="deviceSelect" class="form-select" multiple size="6">
                {% for id, name, _ in devices %}
                <option value="{{ id }}">{{ name }} ({{ id }})</option>
                {% endfor %}
            </select>
        </div>
        <div class="col-12 col-md-6">
            <h5>2. Select Key(s)</h5>
            <div id="keySelectors"></div>
            <div id="keyDeselectors"></div>
        </div>
    </div>
    <div class="mb-3 d-flex gap-2 flex-wrap">
        <button onclick="loadPlot()" class="btn btn-primary">Plot</button>
        <button onclick="exportCSV()" class="btn btn-secondary">Export CSV</button>
        <div class="form-check form-switch ms-3">
            <input class="form-check-input" type="checkbox" id="autoReloadPlotToggle" checked>
            <label class="form-check-label" for="autoReloadPlotToggle">Auto-reload plot</label>
        </div>
        <div class="form-check form-switch ms-3">
            <input class="form-check-input" type="checkbox" id="removeOffsetToggle">
            <label class="form-check-label" for="removeOffsetToggle">Remove offset (start x at 0)</label>
        </div>
            <div class="form-check form-switch ms-3">
                <input class="form-check-input" type="checkbox" id="logYAxisToggle">
                <label class="form-check-label" for="logYAxisToggle">Logarithmic Y axis</label>
            </div>
        <div class="ms-3">
            <label for="xAxisMode" class="form-label">X axis:</label>
            <select id="xAxisMode" class="form-select form-select-sm" style="width: auto; display: inline-block;">
                <option value="date" selected>Date</option>
                <option value="milliseconds">Milliseconds</option> 
                <option value="seconds">Seconds</option>
                <option value="minutes">Minutes</option>
                <option value="hours">Hours</option>
                <option value="days">Days</option>
                <option value="weeks">Weeks</option>
                <option value="months">Months</option>
                <option value="years">Years</option>
            </select>
        </div>
        <div class="form-check form-switch ms-3">
            <input class="form-check-input" type="checkbox" id="syncXZoomToggle">
            <label class="form-check-label" for="syncXZoomToggle">Synchronize X zoom</label>
        </div>
        <div class="ms-3 d-flex align-items-center gap-2">
            <button class="btn btn-outline-secondary btn-sm" id="panBtn">Pan</button>
            <button class="btn btn-outline-secondary btn-sm" id="zoomXBtn">Zoom X</button>
            <button class="btn btn-outline-secondary btn-sm" id="zoomYBtn">Zoom Y</button>
            <button class="btn btn-outline-secondary btn-sm" id="zoomXYBtn">Zoom XY</button>
            <button class="btn btn-outline-secondary btn-sm" id="undoZoomBtn">Undo</button>
            <button class="btn btn-outline-secondary btn-sm" id="redoZoomBtn">Redo</button>
            <button class="btn btn-outline-secondary btn-sm" id="resetZoomBtn">Reset</button>
        </div>
        <div class="ms-3">
            <select id="sourceSelect" class="form-select form-select-sm" style="width: auto; display: inline-block;">
                <option value="device_id" selected>Select Data by Device</option>
                <option value="report_id">Select Data by Report ID</option>
            </select>
            <select id="modeSelect" class="form-select form-select-sm" style="width: auto; display: inline-block;">
                <option value="independent">Time series (Y vs Time)</option>
                <option value="xy">XY plot (X vs Y)</option>
            </select>
        </div>
    </div>
    <hr>
    <div id="chartContainer"></div>
</div>
<script>

let lastSeries = [];
let lastDeselectedKeys = [];
let charts = [];
let zoomMode = 'xy'; // default zoom mode
let zoomHistory = [];
let zoomHistoryIndex = -1;
let chartTypesSelected = [];

/* helpers */
function getSelectedValues(id) {
    const select = document.getElementById(id);
    if (!select) return [];
    return Array.from(document.getElementById(id).selectedOptions)
        .map(o => o.value);
}

function onModeSelect(){
    chartTypesSelected = [];
    loadKeys();
}

function toggleSelectAll(id, doSelect, runFunction) {
    const select = document.getElementById(id);
    if (!select) return;
    for(let i=0; i<select.options.length; i++){
        select.options[i].selected = doSelect;
    }
    if (runFunction) {
        runFunction();
    }
}

function onSplitPlotsToggle(){
    const split = document.getElementById("splitPlots").checked;
    if(chartTypesSelected[0]){
        if(split){
            for(let i=0; i<lastSeries.length; i++){
                if(chartTypesSelected.length < i){
                    chartTypesSelected[i] = chartTypesSelected[0];
                }
            }
        }else{
            first = chartTypesSelected[0];
            chartTypesSelected = [];
            chartTypesSelected[0] = first;
        }
    }
    autoloadPlot();
}

document.getElementById("deviceSelect").addEventListener("change", loadKeys);
document.getElementById("modeSelect").addEventListener("change", onModeSelect);
document.getElementById("sourceSelect").addEventListener("change", loadKeys);

document.getElementById("removeOffsetToggle").addEventListener("change", autoloadPlot);
document.getElementById("logYAxisToggle").addEventListener("change", autoloadPlot);
document.getElementById("xAxisMode").addEventListener("change", autoloadPlot);
document.getElementById("autoReloadPlotToggle").addEventListener("change", autoloadPlot);

function autoloadPlot() {
    if (document.getElementById("autoReloadPlotToggle").checked) {
        loadPlot();
    }
}

function deselectKeyAndRenderChart(){
    const mode = document.getElementById("modeSelect").value;
    lastDeselectedKeys = getSelectedValues("keysToDeselect");
    renderChart(mode, lastSeries);
}

async function loadKeys() {
    const deviceIds = getSelectedValues("deviceSelect");
    if (deviceIds.length === 0) return;

    const source = document.getElementById("sourceSelect").value;
    let api_call = "";
    if (source === "report_id") {
        api_call = "/api/get/reportedValues/report_ids";
    } else if( source === "device_id" ){
        api_call = "/api/get/reportedValues/keys";
    }

    const res = await fetch(api_call, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({ device_ids: deviceIds })
    });

    const keys = await res.json();
    const mode = document.getElementById("modeSelect").value;
    const containerKeySelect = document.getElementById("keySelectors");

    containerKeySelect.innerHTML = "";

    if (mode === "independent") {
        containerKeySelect.innerHTML = `
            <select id="keys" multiple size="6">
                ${keys.map(k => `<option value="${k}">${k}</option>`).join("")}
            </select>
            <br><br>
            <div class="form-check form-check-inline me-3">
                <input class="form-check-input" type="checkbox" id="splitPlots">
                <label class="form-check-label" for="splitPlots">
                    One plot per key
                </label>
            </div>

            <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="selectAllKeys">
                <label class="form-check-label" for="selectAllKeys">
                    Select all keys
                </label>
            </div>
        `;
        document.getElementById("splitPlots").addEventListener("change", onSplitPlotsToggle);
        document.getElementById("selectAllKeys").addEventListener("change", () => toggleSelectAll("keys", document.getElementById("selectAllKeys").checked, autoloadPlot));
        document.getElementById("keys").addEventListener("change", autoloadPlot);
    } else {
        containerKeySelect.innerHTML = `
            X:
            <select id="xKey">
                ${keys.map(k => `<option value="${k}">${k}</option>`).join("")}
            </select>
            Y:
            <select id="yKey">
                ${keys.map(k => `<option value="${k}">${k}</option>`).join("")}
            </select>
        `;
        document.getElementById("xKey").addEventListener("change", autoloadPlot);
        document.getElementById("yKey").addEventListener("change", autoloadPlot);
    }

    const containerKeyDeSelect = document.getElementById("keyDeselectors");
    containerKeyDeSelect.innerHTML = "";
}

async function loadPlot() {
    const mode = document.getElementById("modeSelect").value;
    const payload = { mode };

    const source = document.getElementById("sourceSelect").value;


    if (mode === "independent") {
        payload.device_ids = getSelectedValues("deviceSelect");
        payload.keys = getSelectedValues("keys");
    } else {
        if( source === "report_id") {
            alert("XY plot mode with Report ID source is not supported.");
            return;
        } else {
            payload.device_id = getSelectedValues("deviceSelect")[0];
            payload.x_key = document.getElementById("xKey").value;
            payload.y_key = document.getElementById("yKey").value;
        }
    }

    let api_call = "";
    if ( source === "report_id") {
        api_call = "/api/get/reportedValues/via_report_id";
    } else if (source === "device_id") {
        api_call = "/api/get/reportedValues/via_device_id";
    }

    const res = await fetch(api_call, {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify(payload)
    });

    const data = await res.json();
    if (source == "report_id") {
        // expect jsonify({"data": result, "uniqueKeys": list(uniqueKeys)})
        if (!data.data || !Array.isArray(data.data) || !data.uniqueKeys || !Array.isArray(data.uniqueKeys)) {
            console.error("Expected data json object with data and uniqueKeys arrays, got:", data);
            alert("Backend error – see console");
            return;
        }
        lastSeries = data.data; 
    } else if (source === "device_id") {
        // expect plain array of series
        if (!data || !Array.isArray(data)) {
            console.error("Expected data array, got:", data);
            alert("Backend error – see console");
            return;
        }
        lastSeries = data;
    }

    const containerKeyDeSelect = document.getElementById("keyDeselectors");
    containerKeyDeSelect.innerHTML = "";
    if( source === "report_id" ){
        containerKeyDeSelect.style.display = "block";
        containerKeyDeSelect.innerHTML = `
            <h5>Deselect Keys</h5>
            <select id="keysToDeselect" multiple size="6">
                ${data.uniqueKeys.map(k => `<option value="${k}">${k}</option>`).join("")}
            </select>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="selectAllDeselectKeys">
                <label class="form-check-label" for="selectAllDeselectKeys">
                    Select all keys
                </label>
            </div>
        `;
        const keyDeselctorContainer = document.getElementById("keysToDeselect");

        for(let i=0; i<keyDeselctorContainer.options.length; i++){
            const option = keyDeselctorContainer.options[i];
            if(lastDeselectedKeys.includes(option.value)){
                option.selected = true;
            }
        }

        keyDeselctorContainer.addEventListener("click", deselectKeyAndRenderChart);
        document.getElementById("selectAllDeselectKeys").addEventListener("change", () => toggleSelectAll("keysToDeselect", document.getElementById("selectAllDeselectKeys").checked, deselectKeyAndRenderChart));
    }

    if (source == "report_id") {
        lastSeries = data.data; 
        renderChart(mode, data.data);
        return;
    }
    lastSeries = data; 
    renderChart(mode, data);
}

function createHistograms(chart) {
    const histograms = [];

    let globalMin = Infinity;
    let globalMax = -Infinity;
    let minBinSize = Infinity;

    // Step 1: read values from all datasets
    chart.data.datasets.forEach(dataset => {
        const values = dataset.data.map(p => p.y).sort((a, b) => a - b);
        if (values.length === 0) return;

        console.log(`Creating histogram for dataset "${dataset.label}" with ${values.length} values, min=${values[0]}, max=${values[values.length - 1]},,, from dataset.data:`, dataset.data);
        console.log(values);

        // Freedman-Diaconis bin count
        const numValues = values.length;
        const q75 = values[Math.floor(numValues * 0.75)];
        const q25 = values[Math.floor(numValues * 0.25)];
        const iqr = q75 - q25;
        const bins = Math.max(1, Math.ceil(2 * iqr / Math.pow(numValues, 1 / 3)));
        console.log(`numValues=${numValues}, q25=${q25}, q75=${q75}, iqr=${iqr}, bins=${bins}, Math.pow(numValues, 1 / 3)=${Math.pow(numValues, 1 / 3)}`);

        const min = Math.min(...values);
        const max = Math.max(...values);
        let binSize = (max - min) / bins;
        if (binSize === 0) binSize = 1;

        if (min < globalMin) globalMin = min;
        if (max > globalMax) globalMax = max;
        if (minBinSize > binSize) minBinSize = binSize;

        console.log(`Dataset "${dataset.label}": bins=${bins}, min=${min}, max=${max}, binSize=${binSize}`);

        const histogramData = new Array(bins).fill(0);
        values.forEach(v => {
            const binIndex = Math.min(Math.floor((v - min) / binSize), bins - 1);
            histogramData[binIndex]++;
        });

        const labels = histogramData.map((_, i) => (min + i * binSize).toFixed(2));

        histograms.push({
            label: dataset.label + " (histogram)",
            data: histogramData,
            labels: labels,
            backgroundColor: dataset.backgroundColor || "rgba(75,192,192,0.5)"
        });
    });

    // Step 2: clear chart data
    chart.data.datasets = [];
    chart.data.labels = [];

    // Step 3: write new histogram data
    histograms.forEach((hist, idx) => {
        chart.data.datasets.push({
            label: hist.label,
            data: hist.data,
            backgroundColor: hist.backgroundColor
        });
    });

    // linspace between globalMin and globalMax with stepwith minBinSize
    const labels = [];
    for (let v = globalMin; v <= globalMax; v += minBinSize) {
        labels.push(v.toFixed(2));
    }
    chart.data.labels = labels;

    chart.config.type = "bar";

    // Step 4: update axes for counts
    if (chart.options.scales) {
        chart.options.scales.x = { title: { display: true, text: "Value bins" } };
        chart.options.scales.y = { beginAtZero: true, title: { display: true, text: "Count" } };
    }

    chart.update();
}


function clearCharts() {
    charts.forEach(c => c.destroy());
    charts = [];
    document.getElementById("chartContainer").innerHTML = "";
    zoomHistory = [];
    zoomHistoryIndex = -1;
}

function renderChart(mode, data) {
    clearCharts();

    const source = document.getElementById("sourceSelect").value;
    
    function skipDeselectedKeys(key) {
        if(source == "report_id"){
            const deselectedKeys = getSelectedValues("keysToDeselect");
            const decisiion = deselectedKeys.includes(key);
            return decisiion
        }
        return false;
    }

    // Helper for zoom state
    function saveZoomState() {
        zoomHistory = zoomHistory.slice(0, zoomHistoryIndex + 1);
        zoomHistory.push(charts.map(c => ({
            x: c.scales.x.min !== undefined || c.scales.x.max !== undefined ? { min: c.scales.x.min, max: c.scales.x.max } : null,
            y: c.scales.y.min !== undefined || c.scales.y.max !== undefined ? { min: c.scales.y.min, max: c.scales.y.max } : null
        })));
        zoomHistoryIndex++;
    }

    // Chart type options
    const chartTypeOptions = [
        { value: "line", label: "Line" },
        { value: "line-fill", label: "Line (Fill)" },
        { value: "line-noline", label: "Line (showLine = false)" },
        { value: "bar", label: "Bar Chart" },
        { value: "bubble", label: "Bubble Chart" },
        { value: "scatter", label: "Scatter" },
        { value: "histogram", label: "Histogram" },
    ];

    function createChartTypeDropdown(defaultType, idx, onChange) {
        const select = document.createElement("select");
        select.className = "form-select form-select-sm mb-2";
        select.style.width = "auto";
        select.dataset.chartIdx = idx;
        chartTypeOptions.forEach(opt => {
            const option = document.createElement("option");
            option.value = opt.value;
            option.textContent = opt.label;
            if (opt.value === defaultType) option.selected = true;
            select.appendChild(option);
        });
        select.addEventListener("change", onChange);
        return select;
    }


    function handleChartTypeChange(e) {
        const idx = parseInt(e.target.dataset.chartIdx);
        const chart = charts[idx];
        const type = e.target.value;

        // Update chart type and options
        let newType = type;
        let fill = false;
        let showLine = true;
        if (type === "line-fill") {
            newType = "line";
            fill = true;
        } else if (type === "line-noline") {
            newType = "line";
            showLine = false;
        } else if (type === "histogram") {
            createHistograms(chart, idx);
            return;
        }

        chartTypesSelected[idx] = { type: newType, fill: fill, showLine:showLine };

        chart.config.type = newType;
        if (chart.config.type === "line") {
            chart.data.datasets.forEach(ds => {
                ds.fill = fill;
                ds.showLine = showLine;
            });
        } else {
            chart.data.datasets.forEach(ds => {
                ds.fill = undefined;
                ds.showLine = undefined;
            });
        }
        chart.update();
    }

    const syncX = document.getElementById("syncXZoomToggle").checked;
    function syncXZoom({chart}) {
        if (!syncX) return;
        const xScale = chart.scales.x;
        charts.forEach(c => {
            if (c !== chart) {
                c.scales.x.options.min = xScale.min;
                c.scales.x.options.max = xScale.max;
                c.update();
            }
        });
    }

    function getZoomOptions() {
        return {
            pan: { enabled: true, mode: zoomMode },
            zoom: {
                wheel: { enabled: false },
                pinch: { enabled: true },
                mode: zoomMode,
                drag: { enabled: true },
                onZoom: syncX ? syncXZoom : undefined,
                onZoomComplete: saveZoomState
            },
            limits: { x: { minRange: 0.0001 }, y: { minRange: 0.0001 } }
        };
    }

    const container = document.getElementById("chartContainer");
    if (mode === "independent") {
        const split = document.getElementById("splitPlots").checked;
        const removeOffset = document.getElementById("removeOffsetToggle").checked;
        const xAxisMode = document.getElementById("xAxisMode").value;
        const logYAxis = document.getElementById("logYAxisToggle").checked;
        
        
        function transformX(points) {
            if (!points.length) return points;
            let offset = removeOffset ? points[0].t : 0;
            return points.map(p => {
                let x = p.t - offset;
                switch (xAxisMode) {
                    case "milliseconds": x = x * 1000; break;
                    case "minutes": x = x / 60; break;
                    case "hours": x = x / 3600; break;
                    case "days": x = x / 86400; break;
                    case "weeks": x = x / (86400 * 7); break;
                    case "months": x = x / (86400 * 30.4375); break;
                    case "years": x = x / (86400 * 365.25); break;
                    case "date": x = (p.t) * 1000; break;
                }
                return { x, y: p.v };
            });
        }

        let xLabel = "Date";
        switch (xAxisMode) {
            case "seconds": xLabel = "Time (s)"; break;
            case "milliseconds": xLabel = "Time (ms)"; break;
            case "minutes": xLabel = "Time (min)"; break;
            case "hours": xLabel = "Time (h)"; break;
            case "days": xLabel = "Time (days)"; break;
            case "weeks": xLabel = "Time (weeks)"; break;
            case "months": xLabel = "Time (months)"; break;
            case "years": xLabel = "Time (years)"; break;
            case "date": xLabel = "Date"; break;
        }

        let xScale = {};
        if (xAxisMode === "date") {
            xScale = {
                type: "time",
                title: { display: true, text: xLabel }
            };
        } else {
            xScale = {
                type: "linear",
                title: { display: true, text: xLabel }
            };
        }

        const plugins = {
            tooltip: {
                callbacks: {
                    label: function(context) {
                        // context.parsed contains the return value of transform
                        // context.raw contains the original data point {t, v} and device_id, key if available
                        let x = context.parsed.x;
                        const scaleType = context.chart.scales.x.type;
                        let formatted = x;
                        if (scaleType === "time" || xAxisMode === "date") {
                            let date = new Date(x);
                            let pad = n => n.toString().padStart(2, '0');
                            formatted = `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
                        } else {
                            // Linear scale: x is seconds or ms, convert if needed
                            if (["milliseconds"].includes(xAxisMode)) x = x / 1000;
                            let date = new Date(x * 1000);
                            let pad = n => n.toString().padStart(2, '0');
                            formatted = `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
                        }
                        // Add device_id and key if available in raw point
                        let extra = "";
                        if (context.raw && context.raw.device_id && context.raw.key) {
                            extra = ` [${context.raw.device_id}:${context.raw.key}]`;
                        }
                        if(context.raw && context.raw.report_id) {
                            extra += ` [Report ID: ${context.raw.report_id}]`;
                        }
                        return `${context.dataset.label || ''}${extra} (x: ${formatted}, y: ${context.parsed.y})`;
                    }
                }
            }
        };

        let yScale = {};
        if (logYAxis) {
            yScale = {
                type: "logarithmic",
                title: { display: true, text: "Value (log)" }
            };
        } else {
            yScale = {
                type: "linear",
                title: { display: true, text: "Value" }
            };
        }

        for (let i = 0; i < data.length; i++) {
            if(split && skipDeselectedKeys(data[i].key)){
                continue;
            }
            const defaultType = "line";
            if(chartTypesSelected.length <= i){
                chartTypesSelected[i] = { type: defaultType, fill: false, showLine: true };
            }
            const dropdown = createChartTypeDropdown(chartTypesSelected[i].type, i, handleChartTypeChange);
            container.appendChild(dropdown);
            const canvas = document.createElement("canvas");
            canvas.style.marginBottom = "40px";
            container.appendChild(canvas);
            const ctx = canvas.getContext("2d");
            let chart = null;
            if (split){
                chart = new Chart(ctx, {
                    type: chartTypesSelected[i].type,
                    data: {
                        datasets: [{
                            label: `${data[i].device_id}:${data[i].key}${data[i].report_id ? ` [Report ID: ${data[i].report_id}]` : ''}`,
                            data: transformX(data[i].points),
                            fill: chartTypesSelected[i].fill,
                            showLine: chartTypesSelected[i].showLine
                        }]
                    },
                    options: {
                        plugins: { zoom: getZoomOptions(), ...plugins },
                        scales: { x: xScale, y: yScale }
                    }
                });
                charts.push(chart);
                continue;
            }
            chart = new Chart(ctx, {
                type: chartTypesSelected[i].type,
                data: {
                    datasets: data.filter(data_i => !skipDeselectedKeys(data_i.key)).map(data_i => ({
                        label: `${data_i.device_id}:${data_i.key}${data_i.report_id ? ` [Report ID: ${data_i.report_id}]` : ''}`,
                        data: transformX(data_i.points),
                        fill: chartTypesSelected[i].fill,
                        showLine: chartTypesSelected[i].showLine
                    }))
                },
                options: {
                    plugins: { zoom: getZoomOptions(), ...plugins },
                    scales: { x: xScale, y: yScale }
                }
            });
            charts.push(chart);
            break; // all data in 1 chart
        }
        
        saveZoomState();
        return;
    }

    // XY mode
    else if (mode === "xy") {        
        for (let i = 0; i < data.length; i++) {
            const s = data[i];
            const defaultType = "scatter";
            if(chartTypesSelected.length <= i){
                chartTypesSelected[i] = { type: defaultType, fill: undefined, showLine: undefined };
            }
            const dropdown = createChartTypeDropdown(chartTypesSelected[i], i, handleChartTypeChange);
            container.appendChild(dropdown);
            const canvas = document.createElement("canvas");
            container.appendChild(canvas);
            const ctx = canvas.getContext("2d");
            const chart = new Chart(ctx, {
                type: chartTypesSelected[i].type,
                data: {
                    datasets: [{
                        label: `${s.x_key || 'X'}:${s.y_key || 'Y'}`,
                        data: s.points,
                        fill: chartTypesSelected[i].fill,
                        showLine: hartTypesSelected[i].showLine
                    }]
                },
                options: {
                    plugins: { zoom: getZoomOptions()},
                    scales: {
                        x: { title: { display: true, text: s.x_key || "X" } },
                        y: { title: { display: true, text: s.y_key || "Y" } }
                    }
                }
            });
            charts.push(chart);
        }
        saveZoomState();
        return;
    }
    alert("Invalid mode: '" + mode + "'");
}

// Zoom/pan controls
function undoZoom() {
    if (zoomHistoryIndex > 0) {
        zoomHistoryIndex--;
        applyZoomState(zoomHistory[zoomHistoryIndex]);
    }
}

function redoZoom() {
    if (zoomHistoryIndex < zoomHistory.length - 1) {
        zoomHistoryIndex++;
        applyZoomState(zoomHistory[zoomHistoryIndex]);
    }
}

function resetZoom() {
    charts.forEach(c => c.resetZoom && c.resetZoom());
    zoomHistoryIndex = 0;
    if (zoomHistory.length) applyZoomState(zoomHistory[0]);
}

function applyZoomState(state) {
    if (!state) return;
    state.forEach((s, i) => {
        const c = charts[i];
        if (!c) return;
        if (s.x) {
            c.scales.x.options.min = s.x.min;
            c.scales.x.options.max = s.x.max;
        } else {
            c.scales.x.options.min = undefined;
            c.scales.x.options.max = undefined;
        }
        if (s.y) {
            c.scales.y.options.min = s.y.min;
            c.scales.y.options.max = s.y.max;
        } else {
            c.scales.y.options.min = undefined;
            c.scales.y.options.max = undefined;
        }
        c.update();
    });
}


const modeButtons = [
    { id: "panBtn", mode: "pan" },
    { id: "zoomXBtn", mode: "x" },
    { id: "zoomYBtn", mode: "y" },
    { id: "zoomXYBtn", mode: "xy" }
];

function highlightModeButton(selectedId) {
    modeButtons.forEach(btn => {
        const el = document.getElementById(btn.id);
        if (el) {
            if (btn.id === selectedId) {
                el.classList.add("active");
                el.classList.remove("btn-outline-secondary");
                el.classList.add("btn-primary");
            } else {
                el.classList.remove("active");
                el.classList.remove("btn-primary");
                el.classList.add("btn-outline-secondary");
            }
        }
    });
}

function setZoomMode(mode) {
    zoomMode = mode;
    charts.forEach(c => {
        c.options.plugins.zoom.pan.mode = mode;
        c.options.plugins.zoom.zoom.mode = mode;
        c.update();
    });
    highlightModeButton(modeButtons.find(btn => btn.mode === mode)?.id);
}

document.getElementById("panBtn").addEventListener("click", () => setZoomMode('pan'));
document.getElementById("zoomXBtn").addEventListener("click", () => setZoomMode('x'));
document.getElementById("zoomYBtn").addEventListener("click", () => setZoomMode('y'));
document.getElementById("zoomXYBtn").addEventListener("click", () => setZoomMode('xy'));
document.getElementById("undoZoomBtn").addEventListener("click", undoZoom);
document.getElementById("redoZoomBtn").addEventListener("click", redoZoom);
document.getElementById("resetZoomBtn").addEventListener("click", resetZoom);

// Set initial highlight
highlightModeButton("zoomXYBtn");


function exportCSV() {
    if (!lastSeries.length) {
        alert("Nothing to export");
        return;
    }

    const rows = ["device_id,key,timestamp,value"];

    lastSeries.forEach(s => {
        s.points
        .slice()
        .sort((a, b) => a.t - b.t)
        .forEach(p => {
            rows.push(`"${s.device_id}","${s.key}",${p.t},${p.v}`);
        });
    });

    const blob = new Blob([rows.join("\n")], { type: "text/csv" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "timeseries.csv";
    a.click();

    URL.revokeObjectURL(url);
}

loadKeys();
</script>

</div>
{{ footer(version=version, git_url=git_url) }}
</body>
</html>
